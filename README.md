# - ch1 스프링 핵심 원리 (기본) -
<br><br>
## 스프링과 객체지향 설계
<br><br>
### 스프링 프레임워크
- 핵심기술  
>스프링 DI 컨테이너, APO, 이벤트, ...
- 웹 기술  
>스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술  
>트랜잭션, JDBC, ORM 지원, XML 지원
- 기술 통합  
>캐시, 이메일, 원격접근, 스케줄링
- 테스트  
>스프링 기반 테스트 지원

### 스프링 부트
- >스프링을 편리하게 사용할 수 있도록 지원.
- >단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- >Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- >손쉬운 빌드 구성을 위한 starter 종속성 제공
- >스프링과 3rd path(외부) 라이브러리 자동 구성
- >메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- >관례에 의한 간결한 설정

### 스프링의 진짜 핵심
- >객체지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- >좋은 객체지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크

### 역할과 구현을 분리
- >역할과 구현으로 구분하면 코드가 단순해지고, 유연해지며 변경도 편리해진다.
- >객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기.
- >장점  
클라이언트는 대상의 역할(인터페이스)만 알면 된다.  
클라이언트는 구현 대상의 내부 구조를 몰라도 된다.  
클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.  
클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.

### 좋은 객체지향 설계의 5 원칙 (SOLID)
- >SRP : 단일 책임 원칙 (Single Responsibility Principle) <br><br>
한 클래스는 하나의 책임만 가짐. <br>
하나의 책임이라는 것은 모호함. <br>
중요한 기준은 **변경**. <br>
변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것.
- >OCP : 개방-폐쇄 원칙 (Open/Closed Principle) <br><br>
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 함.<br>
이게 대체 뭔소린가?<br>
다형성을 활용하여 인터페이스는 변경(수정)하지 않고,<br>
구현 객체만 확장(수정)해야 함.<br>
이렇게 객체를 생성하고, 연관관계를 맺어주는 <br>
별도의 조립, 설정자가 필요하다. (스프링)
- >LSP : 리스코프 치환 원칙 (Liskov Substitution Principle)<br><br>
프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서<br>
하위 타입의 인스턴스로 바꿀 수 있어야 함.<br>
다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것.<br>
다형성을 지원하기 위한 원칙으로, 인터페이스를 구현한 구현체를<br> 믿고 사용하려면
이 원칙이 필요함.
- >ISP : 인터페이스 분리 원칙 (Interface Segregation Principle) <br><br>
특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.<br>
자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리.<br>
사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리.
- >DIP : 의존관계 역전 원칙 (Dependency Inversion Principle)<br><br>
프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다."<br>
의존성 주입은 이 원칙을 따르는 방법 중 하나.<br>
쉽게 생각하면 클라이언트 코드가 구현클래스를 바라보지 말고,<br>
인터페이스만 바라보라는 뜻.
- > **정리**<br><br>
  > 다형성만으로는 쉽게 부품 갈아 끼우듯 개발할 수 없다.<br>
  > 다형성만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.<br>
  > 다형성만으로는 OCP, DIP 지킬 수 없다.<br>
  > 뭔가 더 필요하다.

### 객체지향 설계와 스프링
- >스프링의 Di와 DI컨테이너로 OCP,DIP를 가능하게 지원.<br>
- >클라이언트 코드 변경 없이 기능 확장.
- >쉽게, 부품을 교체하듯 개발 가능.

### 스프링 컨테이너
- >'ApplicationContext'를 스프링 컨테이너라 한다.<br>
- >기존에는 개발자가 'Appconfig'를 사용해서 직접 객체 생성하고 DI를 했지만<br>
이제부터 스프링 컨테이너를 통해서 사용한다.
- >스프링 컨테이너는 '@Configuration'이 붙은 'AppConfig'를 설정(구성)정보로 사용한다.<br>
여기서 @Bean이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다.<br>
이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다.
- >스프링 빈은 @Bean이 붙은 메서드의 이름을 스프링 빈의 이름으로 사용한다.
- >이전에는 개발자가 필요한 객체를 'Appconfig'를 사용해서 직접 조회했지만,<br>
이제부터는 스프링 컨테이너를 통해서 필요한 스프링 빈(객체)를 찾아야 한다.<br>
스프링 빈은 'applicationContext.getBean()'메서드를 사용해서 찾는다.
- > 이렇게 스프링 컨테이너를 사용하면 어떤 장점이 있는지 알아보자.